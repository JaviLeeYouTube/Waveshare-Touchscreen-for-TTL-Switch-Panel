// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: UI v5

#include "lvgl.h"
#include "ui_helpers.h"
#include "ui_events.h"
#include "nvs_flash.h"  // Added to enable NVS functionality
#include "nvs.h"        // Added to enable NVS functionality
#include "esp_err.h"    // Added to handle ESP errors
#include "esp_log.h"
#include <stdio.h>
#include <string.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <ctype.h>  // Needed for isspace()
#include "esp_system.h"  // Required for esp_restart()

///////////////////// VARIABLES ////////////////////
void update_button_label(lv_obj_t * button, const char * text) {
    // Check if the button already has a label, if not, create one
    lv_obj_t * label = lv_obj_get_child(button, 0); // Assuming only one child (the label)
    if (!label) {
        label = lv_label_create(button);
        lv_obj_set_parent(label, button); // Attach label to the button
    }

    // Set the label's width to match the button's width
    lv_obj_set_width(label, lv_obj_get_width(button));

    // Enable word wrapping for long texts
    lv_label_set_long_mode(label, LV_LABEL_LONG_WRAP);

    // Set the label's initial text
    lv_label_set_text(label, text);

 // Align the label text to the center of the button
    lv_obj_align(label, LV_ALIGN_CENTER, 0, 0); // Center on both axes
    lv_obj_set_style_text_align(label, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN);

    // Start with a base font and reduce size if the text doesn't fit
    const lv_font_t * base_font = &lv_font_montserrat_30; // Start with a larger font
    lv_obj_set_style_text_font(label, base_font, LV_PART_MAIN);

    // Auto-scale font size to fit the text within the button
    while (lv_obj_get_height(label) > lv_obj_get_height(button)) {
        // Check current font size and step down
        if (base_font == &lv_font_montserrat_30) {
            base_font = &lv_font_montserrat_26;
        } else if (base_font == &lv_font_montserrat_26) {
            base_font = &lv_font_montserrat_24;
        } else {
            // Minimum font size reached, stop scaling
            break;
        }

        // Apply the new font
        lv_obj_set_style_text_font(label, base_font, LV_PART_MAIN);
        lv_label_set_text(label, text); // Reapply text for the new font
    }
}

static void delayed_reset_cb(lv_timer_t * timer) {
    // Reset the ESP32 after 5 seconds
    esp_restart();
}

void load_labels_from_nvs(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    if (err == ESP_OK) {
        for (int i = 1; i <= 8; i++) {
            char key[10];
            snprintf(key, sizeof(key), "aux_%d", i);

            // First, determine the size of the stored string
            size_t required_size = 0;
            err = nvs_get_str(nvs_handle, key, NULL, &required_size);

            if (err == ESP_OK && required_size > 0) {
                // Allocate buffer of the exact required size
                char *label_text = malloc(required_size);
                if (label_text == NULL) {
                    ESP_LOGE("NVS", "Failed to allocate memory for AUX %d label", i);
                    continue;
                }

                // Now get the label value
                err = nvs_get_str(nvs_handle, key, label_text, &required_size);
                if (err == ESP_OK) {
                    // Successfully read the label from NVS
                    lv_obj_t *button = NULL;
                    switch (i) {
                        case 1: button = ui_AUX_1; break;
                        case 2: button = ui_AUX_2; break;
                        case 3: button = ui_AUX_3; break;
                        case 4: button = ui_AUX_4; break;
                        case 5: button = ui_AUX_5; break;
                        case 6: button = ui_AUX_6; break;
                        case 7: button = ui_AUX_7; break;
                        case 8: button = ui_AUX_8; break;
                        default: break;
                    }

                    if (button != NULL) {
                        update_button_label(button, label_text);
                        ESP_LOGI("NVS", "Label for AUX %d loaded from NVS and updated: %s", i, label_text);
                    }
                } else {
                    ESP_LOGE("NVS", "Failed to read label for AUX %d from NVS, error: %s", i, esp_err_to_name(err));
                }

                // Free allocated memory
                free(label_text);
            } else if (err == ESP_ERR_NVS_NOT_FOUND) {
                ESP_LOGI("NVS", "Label for AUX %d not found in NVS, keeping default", i);
            } else {
                ESP_LOGE("NVS", "Failed to determine required size for AUX %d, error: %s", i, esp_err_to_name(err));
            }
        }

        nvs_close(nvs_handle);
    } else {
        ESP_LOGE("NVS", "Failed to open NVS handle for reading");
    }
}




void save_all_labels_task(void *param) {
    vTaskDelay(100 / portTICK_PERIOD_MS);  // Delay for 100ms to let other UI tasks finish

    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err == ESP_OK) {
        char label_text[32];  // Assuming max length is 31 characters + '\0'

        // Iterate over all labels and save them to NVS
        for (int i = 1; i <= 8; i++) {
            const char *new_text = NULL;

            // Retrieve the text for each text area
            switch (i) {
                case 1: new_text = lv_textarea_get_text(ui_ta_aux_1); break;
                case 2: new_text = lv_textarea_get_text(ui_ta_aux_2); break;
                case 3: new_text = lv_textarea_get_text(ui_ta_aux_3); break;
                case 4: new_text = lv_textarea_get_text(ui_ta_aux_4); break;
                case 5: new_text = lv_textarea_get_text(ui_ta_aux_5); break;
                case 6: new_text = lv_textarea_get_text(ui_ta_aux_6); break;
                case 7: new_text = lv_textarea_get_text(ui_ta_aux_7); break;
                case 8: new_text = lv_textarea_get_text(ui_ta_aux_8); break;
                default: break;
            }

            if (new_text != NULL && strlen(new_text) > 0) {
                // Check if new_text is only whitespace
                bool is_blank = true;
                for (size_t j = 0; j < strlen(new_text); j++) {
                    if (!isspace((unsigned char)new_text[j])) {
                        is_blank = false;
                        break;
                    }
                }

                if (!is_blank) {
                    // Only save non-blank labels
                    snprintf(label_text, sizeof(label_text), "%s", new_text);

                    // Save the label to NVS
                    char key[10];
                    snprintf(key, sizeof(key), "aux_%d", i);
                    err = nvs_set_str(nvs_handle, key, label_text);
                    if (err == ESP_OK) {
                        ESP_LOGI("NVS", "Label for AUX %d saved to NVS: %s", i, label_text);
                    } else {
                        ESP_LOGE("NVS", "Failed to save label for AUX %d", i);
                    }
                } else {
                    ESP_LOGI("NVS", "Label for AUX %d is blank or whitespace and will not overwrite saved value", i);
                }
            } else {
                ESP_LOGI("NVS", "Label for AUX %d is empty and will not overwrite saved value", i);
            }
        }

        // Commit changes to NVS
        err = nvs_commit(nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("NVS", "Failed to commit changes to NVS");
        }

        nvs_close(nvs_handle);
    } else {
        ESP_LOGE("NVS", "Failed to open NVS handle for writing");
    }

    vTaskDelete(NULL);  // Delete the task once done
}

// Function to trigger the save labels task
void save_all_labels_async(void) {
    xTaskCreate(save_all_labels_task, "save_labels_task", 8192, NULL, 5, NULL);
}

// SCREEN: ui_Screen1
void ui_Screen1_screen_init(void);
void ui_event_Screen1(lv_event_t * e);
lv_obj_t * ui_Screen1;
lv_obj_t * ui_Panel1;
void ui_event_AUX_1(lv_event_t * e);
lv_obj_t * ui_AUX_1;
lv_obj_t * ui_Label_1;
void ui_event_AUX_2(lv_event_t * e);
lv_obj_t * ui_AUX_2;
lv_obj_t * ui_Label_2;
void ui_event_AUX_3(lv_event_t * e);
lv_obj_t * ui_AUX_3;
lv_obj_t * ui_Label_3;
void ui_event_AUX_4(lv_event_t * e);
lv_obj_t * ui_AUX_4;
lv_obj_t * ui_Label_4;
void ui_event_AUX_5(lv_event_t * e);
lv_obj_t * ui_AUX_5;
lv_obj_t * ui_Label_5;
void ui_event_AUX_6(lv_event_t * e);
lv_obj_t * ui_AUX_6;
lv_obj_t * ui_Label_6;
void ui_event_AUX_7(lv_event_t * e);
lv_obj_t * ui_AUX_7;
lv_obj_t * ui_Label_7;
void ui_event_AUX_8(lv_event_t * e);
lv_obj_t * ui_AUX_8;
lv_obj_t * ui_Label_8;
void ui_event_ALL_ON(lv_event_t * e);
lv_obj_t * ui_ALL_ON;
lv_obj_t * ui_Label10;
void ui_event_ALL_OFF(lv_event_t * e);
lv_obj_t * ui_ALL_OFF;
lv_obj_t * ui_Label11;
lv_obj_t * ui_Battery_Panel;
void ui_event_Battery_Gauge(lv_event_t * e);
lv_obj_t * ui_Battery_Gauge;
lv_obj_t * ui_Voltage_Meter;
lv_obj_t * ui_Battery_Voltage_Label;
lv_obj_t * ui_voltage_label;
void ui_event_Setup_Button(lv_event_t * e);
lv_obj_t * ui_Setup_Button;
void ui_event_Label1(lv_event_t * e);
lv_obj_t * ui_Label1;
// CUSTOM VARIABLES
lv_obj_t * uic_AUX_1;
lv_obj_t * uic_Label_1;
lv_obj_t * uic_AUX_2;
lv_obj_t * uic_Label_2;
lv_obj_t * uic_AUX_3;
lv_obj_t * uic_Label_3;
lv_obj_t * uic_AUX_4;
lv_obj_t * uic_Label_4;
lv_obj_t * uic_AUX_5;
lv_obj_t * uic_Label_5;
lv_obj_t * uic_AUX_6;
lv_obj_t * uic_Label_6;
lv_obj_t * uic_AUX_7;
lv_obj_t * uic_Label_7;
lv_obj_t * uic_AUX_8;
lv_obj_t * uic_Label_8;
lv_obj_t * uic_ALL_ON;
lv_obj_t * uic_ALL_OFF;
lv_obj_t * uic_Battery_Panel;
lv_obj_t * uic_Battery_Gauge;
lv_obj_t * uic_Voltage_Meter;
lv_obj_t * uic_Battery_Voltage_Label;
lv_obj_t * uic_voltage_label;


// SCREEN: ui_Setup_Screen
void ui_Setup_Screen_screen_init(void);
lv_obj_t * ui_Setup_Screen;
void ui_event_ta_aux_1(lv_event_t * e);
lv_obj_t * ui_ta_aux_1;
void ui_event_ta_aux_2(lv_event_t * e);
lv_obj_t * ui_ta_aux_2;
void ui_event_ta_aux_3(lv_event_t * e);
lv_obj_t * ui_ta_aux_3;
void ui_event_ta_aux_4(lv_event_t * e);
lv_obj_t * ui_ta_aux_4;
void ui_event_ta_aux_5(lv_event_t * e);
lv_obj_t * ui_ta_aux_5;
void ui_event_ta_aux_6(lv_event_t * e);
lv_obj_t * ui_ta_aux_6;
void ui_event_ta_aux_7(lv_event_t * e);
lv_obj_t * ui_ta_aux_7;
void ui_event_ta_aux_8(lv_event_t * e);
lv_obj_t * ui_ta_aux_8;
lv_obj_t * ui_Keyboard2;
void ui_event_Save_Button(lv_event_t * e);
lv_obj_t * ui_Save_Button;
void ui_event_Save_Label(lv_event_t * e);
lv_obj_t * ui_Save_Label;
// CUSTOM VARIABLES
lv_obj_t * uic_ta_aux_1;
lv_obj_t * uic_ta_aux_2;
lv_obj_t * uic_ta_aux_3;
lv_obj_t * uic_ta_aux_4;
lv_obj_t * uic_ta_aux_5;
lv_obj_t * uic_ta_aux_6;
lv_obj_t * uic_ta_aux_7;
lv_obj_t * uic_ta_aux_8;
lv_obj_t * uic_Save_Button;
lv_obj_t * uic_Save_Label;

// EVENTS
lv_obj_t * ui____initial_actions0;

// IMAGES AND IMAGE SETS

///////////////////// TEST LVGL SETTINGS ////////////////////
#if LV_COLOR_DEPTH != 16
    #error "LV_COLOR_DEPTH should be 16bit to match SquareLine Studio's settings"
#endif
#if LV_COLOR_16_SWAP !=0
    #error "LV_COLOR_16_SWAP should be 0 to match SquareLine Studio's settings"
#endif

///////////////////// ANIMATIONS ////////////////////

///////////////////// FUNCTIONS ////////////////////
void ui_event_Screen1(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_PRESSED) {
        _ui_screen_change(&ui_Setup_Screen, LV_SCR_LOAD_ANIM_FADE_ON, 10, 0, &ui_Setup_Screen_screen_init);
    }
}

void ui_event_AUX_1(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_1_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_1_off(e);
    }
}

void ui_event_AUX_2(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_2_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_2_off(e);
    }
}

void ui_event_AUX_3(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_3_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_3_off(e);
    }
}

void ui_event_AUX_4(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_4_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_4_off(e);
    }
}

void ui_event_AUX_5(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_5_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_5_off(e);
    }
}

void ui_event_AUX_6(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_6_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_6_off(e);
    }
}

void ui_event_AUX_7(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_7_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_7_off(e);
    }
}

void ui_event_AUX_8(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    if(event_code == LV_EVENT_VALUE_CHANGED &&  lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_8_on(e);
    }
    if(event_code == LV_EVENT_VALUE_CHANGED &&  !lv_obj_has_state(target, LV_STATE_CHECKED)) {
        aux_8_off(e);
    }
}

void ui_event_ALL_OFF(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_PRESSED) {
        _ui_state_modify(ui_AUX_1, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_1_off(NULL);
        _ui_state_modify(ui_AUX_2, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_2_off(NULL);
        _ui_state_modify(ui_AUX_3, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_3_off(NULL);
        _ui_state_modify(ui_AUX_4, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_4_off(NULL);
        _ui_state_modify(ui_AUX_5, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_5_off(NULL);
        _ui_state_modify(ui_AUX_6, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_6_off(NULL);
        _ui_state_modify(ui_AUX_7, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_7_off(NULL);
        _ui_state_modify(ui_AUX_8, LV_STATE_CHECKED, _UI_MODIFY_STATE_REMOVE);
        aux_8_off(NULL);
    }
}

void ui_event_ALL_ON(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_PRESSED) {
        _ui_state_modify(ui_AUX_1, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_1_on(NULL);
        _ui_state_modify(ui_AUX_2, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_2_on(NULL);
        _ui_state_modify(ui_AUX_3, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_3_on(NULL);
        _ui_state_modify(ui_AUX_4, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_4_on(NULL);
        _ui_state_modify(ui_AUX_5, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_5_on(NULL);
        _ui_state_modify(ui_AUX_6, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_6_on(NULL);
        _ui_state_modify(ui_AUX_7, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_7_on(NULL);
        _ui_state_modify(ui_AUX_8, LV_STATE_CHECKED, _UI_MODIFY_STATE_ADD);
        aux_8_on(NULL);
    }
}

void ui_event_Battery_Gauge(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        update_voltage_event_handler(e);
        update_voltage_label(e);
    }
}

void ui_event_Setup_Button(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_PRESSED) {
        _ui_screen_change(&ui_Setup_Screen, LV_SCR_LOAD_ANIM_NONE, 10, 0, &ui_Setup_Screen_screen_init);
    }
}

void ui_event_Label1(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_PRESSED) {
        _ui_screen_change(&ui_Setup_Screen, LV_SCR_LOAD_ANIM_FADE_ON, 100, 0, &ui_Setup_Screen_screen_init);
    }
}

void ui_event_ta_aux_1(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2, ui_ta_aux_1);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        const char * new_text = lv_textarea_get_text(ui_ta_aux_1);
               
        // Update the label
        update_button_label(ui_AUX_1, new_text);

    }
}


void ui_event_ta_aux_2(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2, ui_ta_aux_2);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        const char * new_text = lv_textarea_get_text(ui_ta_aux_2);
        
        // Update the label
        update_button_label(ui_AUX_2, new_text);  

    }
}


void ui_event_ta_aux_3(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2,  ui_ta_aux_3);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char * new_text = lv_textarea_get_text(ui_ta_aux_3);

        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_3, new_text);
        
    }
}

void ui_event_ta_aux_4(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2,  ui_ta_aux_4);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char * new_text = lv_textarea_get_text(ui_ta_aux_4);

        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_4, new_text);

    }
}

void ui_event_ta_aux_5(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2,  ui_ta_aux_5);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char * new_text = lv_textarea_get_text(ui_ta_aux_5);

        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_5, new_text);

    }
}

void ui_event_ta_aux_6(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2,  ui_ta_aux_6);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if(event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char * new_text = lv_textarea_get_text(ui_ta_aux_6);

        // Set the label for the AUX button dynamically
        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_6, new_text);      

    }
}

void ui_event_ta_aux_7(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2, ui_ta_aux_7);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if (event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char *new_text = lv_textarea_get_text(ui_ta_aux_7);

        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_7, new_text);

     
    }
}

void ui_event_ta_aux_8(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if (event_code == LV_EVENT_FOCUSED) {
        _ui_keyboard_set_target(ui_Keyboard2, ui_ta_aux_8);
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }

    if (event_code == LV_EVENT_VALUE_CHANGED) {
        // Get the current text from the text area
        const char *new_text = lv_textarea_get_text(ui_ta_aux_8);

        // Update the label for the AUX button dynamically with word wrapping or shrinking
        update_button_label(ui_AUX_8, new_text);

    }
}


void ui_event_Save_Button(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_CLICKED) {
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
        _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_MOVE_LEFT, 100, 0, &ui_Screen1_screen_init);
        save_all_labels_async();
        ESP_LOGI("Save", "Saving all labels in a separate task");
        lv_timer_create(delayed_reset_cb, 3000, NULL);
    }
}

void ui_event_Save_Label(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);

    if(event_code == LV_EVENT_CLICKED) {
        _ui_flag_modify(ui_Keyboard2, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_ADD);
        _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_MOVE_LEFT, 100, 0, &ui_Screen1_screen_init);
        save_all_labels_async();
        ESP_LOGI("Save", "Saving all labels in a separate task");
        lv_timer_create(delayed_reset_cb, 3000, NULL);
    }
}

///////////////////// SCREENS ////////////////////

void ui_init(void)
{
    lv_disp_t * dispp = lv_disp_get_default();
    lv_theme_t * theme = lv_theme_basic_init(dispp);
    lv_disp_set_theme(dispp, theme);
    ui_Screen1_screen_init();
    ui_Setup_Screen_screen_init();
    ui____initial_actions0 = lv_obj_create(NULL);
    lv_disp_load_scr(ui_Screen1);
}
