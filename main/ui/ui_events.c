// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: UI v5

#include "ui.h"
#include <stdint.h>
#include <stdio.h>
#include <driver/adc.h>

extern uint8_t controlByte;  // Declare controlByte as external
extern void sendControlByte();  // Declare sendControlByte

float read_battery_voltage() {
    // Configure ADC width and attenuation
    adc1_config_width(ADC_WIDTH_BIT_12);       // Set ADC resolution to 12 bits
    adc1_config_channel_atten(ADC1_CHANNEL_6, ADC_ATTEN_DB_12); // Adjust attenuation for 0-3.3V range

    // Read raw ADC value
    int raw_adc = adc1_get_raw(ADC1_CHANNEL_6); // Use the channel mapped to GPIO 6

    // Convert raw ADC value to voltage (assuming 12-bit ADC resolution and 3.3V reference)
    float adc_voltage = (raw_adc / 4095.0) * 3.3;

    // Reverse the voltage divider effect to get the actual battery voltage
    float battery_voltage = adc_voltage * (14.5 / 3.3); // Adjust multiplier for your voltage divider

    return battery_voltage;
}



void aux_1_on(lv_event_t * e) {
    controlByte |= 0x80;  // Set bit 7 for AUX 1
    sendControlByte();
}

void aux_1_off(lv_event_t * e) {
    controlByte &= ~0x80;  // Clear bit 7 for AUX 1
    sendControlByte();
}

void aux_2_on(lv_event_t * e) {
    controlByte |= 0x40;  // Set bit 6 for AUX 2
    sendControlByte();
}

void aux_2_off(lv_event_t * e) {
    controlByte &= ~0x40;  // Clear bit 6 for AUX 2
    sendControlByte();
}

void aux_3_on(lv_event_t * e) {
    controlByte |= 0x20;  // Set bit 5 for AUX 3
    sendControlByte();
}

void aux_3_off(lv_event_t * e) {
    controlByte &= ~0x20;  // Clear bit 5 for AUX 3
    sendControlByte();
}

void aux_4_on(lv_event_t * e) {
    controlByte |= 0x10;  // Set bit 4 for AUX 4
    sendControlByte();
}

void aux_4_off(lv_event_t * e) {
    controlByte &= ~0x10;  // Clear bit 4 for AUX 4
    sendControlByte();
}

void aux_5_on(lv_event_t * e) {
    controlByte |= 0x08;  // Set bit 3 for AUX 5
    sendControlByte();
}

void aux_5_off(lv_event_t * e) {
    controlByte &= ~0x08;  // Clear bit 3 for AUX 5
    sendControlByte();
}

void aux_6_on(lv_event_t * e) {
    controlByte |= 0x04;  // Set bit 2 for AUX 6
    sendControlByte();
}

void aux_6_off(lv_event_t * e) {
    controlByte &= ~0x04;  // Clear bit 2 for AUX 6
    sendControlByte();
}

void aux_7_on(lv_event_t * e) {
    controlByte |= 0x02;  // Set bit 1 for AUX 7
    sendControlByte();
}

void aux_7_off(lv_event_t * e) {
    controlByte &= ~0x02;  // Clear bit 1 for AUX 7
    sendControlByte();
}

void aux_8_on(lv_event_t * e) {
    controlByte |= 0x01;  // Set bit 0 for AUX 8
    sendControlByte();
}

void aux_8_off(lv_event_t * e) {
    controlByte &= ~0x01;  // Clear bit 0 for AUX 8
    sendControlByte();

}

void update_voltage_event_handler(lv_event_t * e) {
    lv_obj_t * bar = lv_event_get_target(e); // Get the bar object
    float voltage = read_battery_voltage();  // Replace with your actual voltage reading function
    int bar_value = (int)((voltage - 10.5) / (14.5 - 10.5) * 100); // Map voltage to bar range (0-100)
    lv_bar_set_value(bar, bar_value, LV_ANIM_OFF); // Update the bar value
}


void update_voltage_label(lv_event_t * e) {
    lv_obj_t * bar = lv_event_get_target(e);

    // Find the label
    lv_obj_t * parent = lv_obj_get_parent(bar);
    lv_obj_t * label = lv_obj_get_child(parent, 0); // Adjust index if necessary

    // Get the voltage
    float voltage = read_battery_voltage(); // Replace with your sensor reading logic

    // Update the bar value
    int bar_value = (int)((voltage - 10.5) / (14.5 - 10.5) * 100); // Map to bar range
    lv_bar_set_value(bar, bar_value, LV_ANIM_OFF);

    // Update the label
    char buf[10];
    sprintf(buf, "%.2f V", voltage); // Format voltage as "12.34 V"
    lv_label_set_text(label, buf);
}

